"""InVEST Coastal Vulnerability"""
import sys
import traceback
import shutil
import time
import os
import math
import logging
import re
import multiprocessing
import zipfile

import numpy
from osgeo import gdal
from osgeo import osr
from osgeo import ogr
import rtree
import shapely
import shapely.wkb
import shapely.ops
import shapely.speedups
import pygeoprocessing
import taskgraph

LOGGER = logging.getLogger(__name__)

# Wave Watch III data does not cover the planet.  Make sure we don't deal
# with a point that's not in range of said point.  I'm picking 1 degree since
# that's double the diagonal distance between two WWIII points
_MAX_WWIII_DISTANCE = 5.0 # RICH: did you later decide 5 degree is better choice than 1?
_N_FETCH_RAYS = 16


# Create shore points within an AOI 
# Clip the landmass vector path by an AOI
# Could pass AOI to create_shore_points and clip landmass (w/ landmass_rtree)
# Or could clip landmass ahead of time and pass clipped landmass to create_shore_points


# just pass aoi vector to create shore points, for create_raster_from_vector_extents
# then rasterize landmass onto that raster. still need to make sure landmass
# is projected to AOI. Then, wind exposure needs a landmass in AOI projection 
# with a buffer of max-fetch-dist. 

def execute(args):

    output_dir = os.path.join(args['workspace_dir'])
    intermediate_dir = os.path.join(
        args['workspace_dir'], 'intermediate')

    utils.make_directories(
        [output_dir, intermediate_dir])

    work_token_dir = os.path.join(intermediate_output_dir, '_tmp_work_tokens')
    try:
        n_workers = int(args['n_workers'])
    except (KeyError, ValueError, TypeError):
        # KeyError when n_workers is not present in args
        # ValueError when n_workers is an empty string.
        # TypeError when n_workers is None.
        n_workers = -1  # Single process mode.
    task_graph = taskgraph.TaskGraph(work_token_dir, n_workers)

    # TODO: reproject global inputs (wwiii, global landmass) to AOI SRS, 
    # Before building rtree?
    # Or, build rtrees for global data, then reproject AOI to match,
    # AOI should be small/simple.
    # - wwiii: I project points to match wwiii, for finding nearest.
    # - landmass: project aoi to landmass, clip landmass, then prj land to aoi
    # - relief/bathy: 
    # - continental shelf: 

    build_wwiii_rtree_task = task_graph.add_task(
        func=build_wwiii_rtree,
        args=(args['wwiii'], wwiii_rtree_path),
        target_path_list=[wwiii_rtree_path]
        task_name='build_wwiii_rtree')

    build_landmass_rtree_task = task_graph.add_task(
        func=build_feature_bounding_box_rtree,
        args=(landmass_vector_path, landmass_rtree_path),
        target_path_list=[landmass_rtree_path],
        task_name='build_landmass_rtree')

    clip_landmass_to_aoi_task = task_graph.add_task(
        func=clip_landmass_to_aoi,
        args=(aoi_vector_path, landmass_vector_path, landmass_rtree_path,
              target_clipped_landmass_path),
        target_path_list=[target_clipped_landmass_path],
        dependent_task_list=[build_landmass_rtree],
        task_name='clip landmass to aoi')

    create_shore_points_task = task_graph.add_task(
        func=create_shore_points,
        args=(landmass_vector_path, wwiii_vector_path, wwiii_rtree_path,
              smallest_feature_size, workspace_dir,
              target_shore_point_vector_path),
        target_path_list=[target_shore_point_vector_path],
        dependent_task_list=[clip_landmass_to_aoi_task, build_wwiii_rtree_task],
        task_name='create shore points')

    calculate_wind_exposure_task = task_graph.add_task(
        func=calculate_wind_exposure,
        args=(base_shore_point_vector_path, landmass_rtree_path,
              landmass_vector_path, workspace_dir, smallest_feature_size,
              max_fetch_distance, target_fetch_point_vector_path),
        target_path_list=[target_fetch_point_vector_path],
        dependent_task_list=[create_shore_points_task],
        task_name='calculate_wind_exposure')

    task_graph.close()
    task_graph.join()


def clip_reproject_landmass_to_aoi(
        aoi_vector_path, landmass_vector_path, landmass_rtree_path,
        target_clipped_landmass_path):
    """Clip landmass polygon to AOI."""

    landmass_vector_rtree = rtree.index.Index(
        os.path.splitext(landmass_rtree_path)[0])
    landmass_srs_wkt = pygeoprocessing.get_vector_info(
        landmass_vector_path)['projection']

    aoi_vector_info = pygeoprocessing.get_vector_info(
        aoi_vector_path)
    aoi_bounding_box = pygeoprocessing.transform_bounding_box(
        aoi_vector_info['bounding_box'], aoi_vector_info['projection'],
        landmass_srs_wkt, edge_samples=11)

    for feature_id in landmass_vector_rtree.intersection(
            aoi_bounding_box):
        try:
            landmass_feature = landmass_layer.GetFeature(feature_id)
            landmass_shapely = shapely.wkb.loads(
                landmass_feature.GetGeometryRef().ExportToWkb())
            intersection_shapely = utm_clipping_shapely.intersection(
                landmass_shapely)
            clipped_geometry = ogr.CreateGeometryFromWkt(
                intersection_shapely.wkt)
            clipped_feature = ogr.Feature(temp_clipped_defn)
            clipped_feature.SetGeometry(clipped_geometry)
            temp_clipped_layer.CreateFeature(clipped_feature)
            clipped_feature = None
        except Exception:
            clipped_feature = None
            LOGGER.warn(
                "Couldn't process this intersection %s",
                intersection_shapely)
    temp_clipped_layer.SyncToDisk()
    temp_clipped_layer = None
    temp_clipped_vector = None

def create_shore_points(
        aoi_vector_path,
        landmass_vector_path, wwiii_vector_path, wwiii_rtree_path,
        smallest_feature_size,
        workspace_dir, target_shore_point_vector_path):
    """Create points that lie on the coast line of the landmass.

    Also join tabular data from Wave Watch 3 to shore points by finding the
    nearest WW3 points to each shore point.

    Parameters:
        landmass_vector_path (string): path to polygon vector representing
            landmass.
        wwiii_vector_path (string): path to point shapefile representing
            the Wave Watch III data.
        wwiii_rtree_path (string): path to an rtree index that has
            the points of `wwiii_vector_path` indexed.
        smallest_feature_size (float): smallest feature size to grid a shore
            point on.
        workspace_dir (string): path to a directory that can be created
            during run to hold temporary files.  Will be deleted on successful
            function completion.
        target_shore_point_vector_path (string): path to a point vector that
            will be created and contain points on the shore of the landmass.

    Returns:
        None.

    """
    # LOGGER.info("Creating shore points for grid %s", grid_fid)
    # create the spatial reference from the base vector
    landmass_spatial_reference = osr.SpatialReference()
    landmass_spatial_reference.ImportFromWkt(
        pygeoprocessing.get_vector_info(landmass_vector_path)['projection'])
    wwiii_spatial_reference = osr.SpatialReference()
    wwiii_spatial_reference.ImportFromWkt(
        pygeoprocessing.get_vector_info(wwiii_vector_path)['projection'])

    # if os.path.exists(workspace_dir):
    #     shutil.rmtree(workspace_dir)
    # os.makedirs(workspace_dir)

    lat_lng_clipped_vector_path = os.path.join(
        workspace_dir, 'clipped_geometry_lat_lng.gpkg')
    grid_raster_path = os.path.join(workspace_dir, 'grid.tif')
    convolution_raster_path = os.path.join(
        workspace_dir, 'convolution.tif')
    utm_clipped_vector_path = os.path.join(
        workspace_dir, 'clipped_geometry_utm.gpkg')
    shore_kernel_path = os.path.join(
        workspace_dir, 'shore_kernel.tif')
    shore_raster_path = os.path.join(
        workspace_dir, 'shore_raster.tif')

    for path in [target_shore_point_vector_path,
                 lat_lng_clipped_vector_path,
                 grid_raster_path]:
        if os.path.exists(path):
            os.remove(path)

    esri_shapefile_driver = ogr.GetDriverByName("ESRI Shapefile")

    # # this will hold the clipped landmass geometry
    # lat_lng_clipped_vector = esri_shapefile_driver.CreateDataSource(
    #     lat_lng_clipped_vector_path)
    # lat_lng_clipped_layer = (
    #     lat_lng_clipped_vector.CreateLayer(
    #         os.path.splitext(lat_lng_clipped_vector_path)[0],
    #         landmass_spatial_reference, ogr.wkbPolygon))
    # lat_lng_clipped_defn = lat_lng_clipped_layer.GetLayerDefn()

    # this will hold the output sample points on the shore
    target_shore_point_vector = esri_shapefile_driver.CreateDataSource(
        target_shore_point_vector_path)
    target_shore_point_layer = target_shore_point_vector.CreateLayer(
        os.path.splitext(target_shore_point_vector_path)[0],
        landmass_spatial_reference, ogr.wkbPoint)

    wwiii_vector = ogr.Open(wwiii_vector_path)
    wwiii_layer = wwiii_vector.GetLayer()
    wwiii_defn = wwiii_layer.GetLayerDefn()
    field_names = []
    for field_index in range(wwiii_defn.GetFieldCount()):
        field_defn = wwiii_defn.GetFieldDefn(field_index)
        field_name = field_defn.GetName()
        if field_name in ['I', 'J']:
            continue
        field_names.append(field_name)
        target_shore_point_layer.CreateField(field_defn)
    target_shore_point_defn = target_shore_point_layer.GetLayerDefn()

    landmass_vector = ogr.Open(landmass_vector_path)
    landmass_layer = landmass_vector.GetLayer()

    # grid_vector = ogr.Open(sample_grid_vector_path)
    # grid_layer = grid_vector.GetLayer()
    # grid_feature = grid_layer.GetFeature(grid_fid)
    # grid_geometry_ref = grid_feature.GetGeometryRef()
    # grid_shapely = shapely.wkb.loads(grid_geometry_ref.ExportToWkb())

    # landmass_vector_rtree = rtree.index.Index(
    #     os.path.splitext(landmass_bounding_rtree_path)[0])

    # project global polygon clip to UTM
    # transform lat/lng box to utm -> local box
    # utm_spatial_reference = get_utm_spatial_reference(grid_shapely.bounds)
    # utm_bounding_box = pygeoprocessing.transform_bounding_box(
    #     grid_shapely.bounds, landmass_spatial_reference.ExportToWkt(),
    #     utm_spatial_reference.ExportToWkt(), edge_samples=11)

    # # add a pixel buffer so we clip land that's a little outside the grid
    # pixel_buffer = 1
    # utm_bounding_box[0] -= pixel_buffer * smallest_feature_size
    # utm_bounding_box[1] -= pixel_buffer * smallest_feature_size
    # utm_bounding_box[2] += pixel_buffer * smallest_feature_size
    # utm_bounding_box[3] += pixel_buffer * smallest_feature_size

    # # transform local box back to lat/lng -> global clipping box
    # lat_lng_clipping_box = pygeoprocessing.transform_bounding_box(
    #     utm_bounding_box, utm_spatial_reference.ExportToWkt(),
    #     landmass_spatial_reference.ExportToWkt(), edge_samples=11)
    # # see if we're wrapped on the dateline
    # if (grid_shapely.bounds[0] > 0 and
    #         lat_lng_clipping_box[0] > lat_lng_clipping_box[2]):
    #     lat_lng_clipping_box[2] += 360
    # elif (grid_shapely.bounds[0] < 0 and
    #       lat_lng_clipping_box[0] > lat_lng_clipping_box[2]):
    #     lat_lng_clipping_box[0] -= 360
    # lat_lng_clipping_shapely = shapely.geometry.box(*lat_lng_clipping_box)

    # # clip global polygon to utm clipping box
    # LOGGER.info(
    #     "clip global polygon to utm clipping box for grid %s", grid_fid)
    # for feature_id in landmass_vector_rtree.intersection(
    #         lat_lng_clipping_box):
    #     try:
    #         base_feature = landmass_layer.GetFeature(feature_id)
    #         base_geometry = base_feature.GetGeometryRef()
    #         base_shapely = shapely.wkb.loads(base_geometry.ExportToWkb())
    #         base_geometry = None
    #         intersection_shapely = lat_lng_clipping_shapely.intersection(
    #             base_shapely)
    #         target_geometry = ogr.CreateGeometryFromWkt(
    #             intersection_shapely.wkt)
    #         target_feature = ogr.Feature(lat_lng_clipped_defn)
    #         target_feature.SetGeometry(target_geometry)
    #         lat_lng_clipped_layer.CreateFeature(target_feature)
    #         target_feature = None
    #         target_geometry = None
    #     except shapely.errors.WKBReadingError:
    #         LOGGER.error("couldn't read fid %d for some reason.", feature_id)
    #     except Exception:
    #         LOGGER.warn(
    #             "Couldn't process this intersection %s",
    #             intersection_shapely)
    # lat_lng_clipped_layer.SyncToDisk()
    # lat_lng_clipped_layer = None
    # lat_lng_clipped_vector = None

    # # create grid for underlying local utm box
    # pygeoprocessing.reproject_vector(
    #     lat_lng_clipped_vector_path, utm_spatial_reference.ExportToWkt(),
    #     utm_clipped_vector_path, driver_name='GPKG')

    byte_nodata = 255

    # utm_clipped_vector_path = landmass_vector_path
    pygeoprocessing.create_raster_from_vector_extents(
        aoi_vector_path,
        grid_raster_path, (
            smallest_feature_size / 2.0, -smallest_feature_size / 2.0),
        gdal.GDT_Byte, byte_nodata, fill_value=0)

    # rasterize utm global clip to grid
    pygeoprocessing.rasterize(
        landmass_vector_path, grid_raster_path, [1], None)

    # grid shoreline from raster
    make_shore_kernel(shore_kernel_path)
    pygeoprocessing.convolve_2d(
        (grid_raster_path, 1), (shore_kernel_path, 1),
        convolution_raster_path, target_datatype=gdal.GDT_Byte,
        target_nodata=255)

    temp_grid_nodata = pygeoprocessing.get_raster_info(
        grid_raster_path)['nodata'][0]

    def _shore_mask_op(shore_convolution):
        """Mask values on land that border water."""
        result = numpy.empty(shore_convolution.shape, dtype=numpy.uint8)
        result[:] = byte_nodata
        valid_mask = shore_convolution != temp_grid_nodata
        # If a pixel is on land, it gets at least a 9, but if it's all on
        # land it gets an 17 (8 neighboring pixels), so we search between 9
        # and 17 to determine a shore pixel
        result[valid_mask] = numpy.where(
            (shore_convolution[valid_mask] >= 9) &
            (shore_convolution[valid_mask] < 17), 1, byte_nodata)
        return result

    pygeoprocessing.raster_calculator(
        [(convolution_raster_path, 1)], _shore_mask_op,
        shore_raster_path, gdal.GDT_Byte, byte_nodata)

    shore_geotransform = pygeoprocessing.get_raster_info(
        shore_raster_path)['geotransform']

    landmass_to_wwiii_transform = osr.CoordinateTransformation(
        landmass_spatial_reference, wwiii_spatial_reference)
    # rtree index loads without the extension
    wwiii_rtree_base_path = os.path.splitext(
        wwiii_rtree_path)[0]
    wwiii_rtree = rtree.index.Index(wwiii_rtree_base_path)
    wwiii_field_lookup = {}

    # LOGGER.info(
    #     "Interpolating shore points with Wave Watch III data for grid %s",
    #     grid_fid)
    feature_lookup = {}
    for offset_info, data_block in pygeoprocessing.iterblocks(
            (shore_raster_path, 1)):
        row_indexes, col_indexes = numpy.mgrid[
            offset_info['yoff']:offset_info['yoff']+offset_info['win_ysize'],
            offset_info['xoff']:offset_info['xoff']+offset_info['win_xsize']]
        valid_mask = data_block == 1
        x_coordinates = (
            shore_geotransform[0] +
            shore_geotransform[1] * (col_indexes[valid_mask] + 0.5) +
            shore_geotransform[2] * (row_indexes[valid_mask] + 0.5))
        y_coordinates = (
            shore_geotransform[3] +
            shore_geotransform[4] * (col_indexes[valid_mask] + 0.5) +
            shore_geotransform[5] * (row_indexes[valid_mask] + 0.5))

        for x_coord, y_coord in zip(x_coordinates, y_coordinates):
            # Set the point geometry in the native SRS
            shore_point_geometry = ogr.Geometry(ogr.wkbPoint)
            shore_point_geometry.AddPoint(x_coord, y_coord)
            shore_point_feature = ogr.Feature(target_shore_point_defn)
            shore_point_feature.SetGeometry(shore_point_geometry)
            
            # Then transform point to match the wwiii SRS to find nearest
            shore_point_geometry.Transform(landmass_to_wwiii_transform)
            # get the nearest wave watch III points from the shore point
            nearest_points = list(wwiii_rtree.nearest(
                (shore_point_geometry.GetX(),
                 shore_point_geometry.GetY(),
                 shore_point_geometry.GetX(),
                 shore_point_geometry.GetY()), 3))[0:3]

            # create placeholders for point geometry and field values
            wwiii_points = numpy.empty((3, 2))
            wwiii_values = numpy.empty((3, len(field_names)))
            for fid_index, fid in enumerate(nearest_points):
                wwiii_feature = wwiii_layer.GetFeature(fid)
                wwiii_geometry = wwiii_feature.GetGeometryRef()
                wwiii_points[fid_index] = numpy.array(
                    [wwiii_geometry.GetX(), wwiii_geometry.GetY()])
                try:
                    wwiii_values[fid_index] = wwiii_field_lookup[fid]
                except KeyError:
                    wwiii_field_lookup[fid] = numpy.array(
                        [float(wwiii_feature.GetField(field_name))
                         for field_name in field_names])
                    wwiii_values[fid_index] = wwiii_field_lookup[fid]
            # import pdb; pdb.set_trace()
            distance = numpy.linalg.norm(
                wwiii_points - numpy.array(
                    (shore_point_geometry.GetX(),
                     shore_point_geometry.GetY())))

            # make sure we're within a valid data distance
            if distance > _MAX_WWIII_DISTANCE:
                continue

            wwiii_values *= distance
            wwiii_values = numpy.mean(wwiii_values, axis=0)
            wwiii_values /= numpy.sum(distance)

            for field_name_index, field_name in enumerate(field_names):
                shore_point_feature.SetField(
                    field_name, wwiii_values[field_name_index])

            target_shore_point_layer.CreateFeature(shore_point_feature)
            shore_point_feature = None
    del feature_lookup
    # LOGGER.info("All done with shore points for grid %s", grid_fid)


def calculate_wind_exposure(
        base_shore_point_vector_path,
        landmass_bounding_rtree_path, landmass_vector_path, workspace_dir,
        smallest_feature_size, max_fetch_distance,
        target_fetch_point_vector_path):
    """Calculate wind exposure for each shore point.

    Parameters:
        base_shore_point_vector_path (string): path to a point shapefile
            representing shore points that should be sampled for wind
            exposure.
        landmass_bounding_rtree_path (string): path to an rtree bounding box
            for the landmass polygons.
        landmass_vector_path (string): path to landmass polygon vetor.
        workspace_dir (string): path to a directory that can be created for
            temporary workspace files
        smallest_feature_size (float): smallest feature size to detect in
            meters.
        max_fetch_distance (float): maximum fetch distance for a ray in
            meters.
        target_fetch_point_vector_path (string): path to target point file,
            will be a copy of `base_shore_point_vector_path`'s geometry with
            an 'REI' (relative exposure index) field added.

    Returns:
        None

    """
    # if os.path.exists(workspace_dir):
    #     shutil.rmtree(workspace_dir)
    # os.makedirs(workspace_dir)

    utm_clipped_vector_path = os.path.join(
        workspace_dir, 'utm_clipped_landmass.gpkg')
    temp_fetch_rays_path = os.path.join(
        workspace_dir, 'fetch_rays.gpkg')

    # reproject base_shore_point_vector_path to utm coordinates
    # base_shore_info = pygeoprocessing.get_vector_info(
    #     base_shore_point_vector_path)
    # base_shore_bounding_box = base_shore_info['bounding_box']

    # still the native user-defined SRS:
    base_ref_wkt = pygeoprocessing.get_vector_info(
        base_shore_point_vector_path)['projection']
    base_spatial_reference = osr.SpatialReference()
    base_spatial_reference.ImportFromWkt(base_ref_wkt)
    # print base_ref_wkt
    # print base_spatial_reference.ExportToWkt()
    # TODO: this is lazy - using pgp.reproject vector to copy geometry without
    # fields. Asking to reproject to the same SRS.
    pygeoprocessing.reproject_vector(
        base_shore_point_vector_path, base_spatial_reference.ExportToWkt(),
        target_fetch_point_vector_path, driver_name='GPKG', copy_fields=False)

    utm_bounding_box = pygeoprocessing.get_vector_info(
        target_fetch_point_vector_path)['bounding_box']

    # extend bounding box for max fetch distance
    utm_bounding_box = [
        utm_bounding_box[0] - max_fetch_distance,
        utm_bounding_box[1] - max_fetch_distance,
        utm_bounding_box[2] + max_fetch_distance,
        utm_bounding_box[3] + max_fetch_distance]

    utm_clipping_shapely = shapely.geometry.box(*utm_bounding_box)
    # # get lat/lng bounding box of utm projected coordinates

    # # get global polygon clip of that utm box
    # # transform local box back to lat/lng -> global clipping box
    # lat_lng_clipping_box = pygeoprocessing.transform_bounding_box(
    #     utm_bounding_box, utm_spatial_reference.ExportToWkt(),
    #     base_spatial_reference.ExportToWkt(), edge_samples=11)
    # if (base_shore_bounding_box[0] > 0 and
    #         lat_lng_clipping_box[0] > lat_lng_clipping_box[2]):
    #     lat_lng_clipping_box[2] += 360
    # elif (base_shore_bounding_box[0] < 0 and
    #       lat_lng_clipping_box[0] > lat_lng_clipping_box[2]):
    #     lat_lng_clipping_box[0] -= 360
    # elif base_shore_bounding_box == [0, 0, 0, 0]:
    #     # this case guards for an empty shore point in case there are
    #     # very tiny islands or such
    #     lat_lng_clipping_box = (0, 0, 0, 0)
    # lat_lng_clipping_shapely = shapely.geometry.box(*lat_lng_clipping_box)

    landmass_vector_rtree = rtree.index.Index(
        os.path.splitext(landmass_bounding_rtree_path)[0])

    landmass_vector = ogr.Open(landmass_vector_path)
    landmass_layer = landmass_vector.GetLayer()

    # this will hold the clipped landmass geometry
    esri_shapefile_driver = ogr.GetDriverByName("GPKG")
    temp_clipped_vector_path = os.path.join(
        workspace_dir, 'clipped_geometry_vector.gpkg')
    temp_clipped_vector = esri_shapefile_driver.CreateDataSource(
        temp_clipped_vector_path)
    temp_clipped_layer = (
        temp_clipped_vector.CreateLayer(
            os.path.splitext(os.path.basename(temp_clipped_vector_path))[0],
            base_spatial_reference, ogr.wkbPolygon))
    temp_clipped_defn = temp_clipped_layer.GetLayerDefn()

    # clip landmass polygon to shore points clipping box
    # clip global polygon to global clipping box
    for feature_id in landmass_vector_rtree.intersection(
            # lat_lng_clipping_box):
            utm_bounding_box):
        try:
            landmass_feature = landmass_layer.GetFeature(feature_id)
            landmass_shapely = shapely.wkb.loads(
                landmass_feature.GetGeometryRef().ExportToWkb())
            intersection_shapely = utm_clipping_shapely.intersection(
                landmass_shapely)
            clipped_geometry = ogr.CreateGeometryFromWkt(
                intersection_shapely.wkt)
            clipped_feature = ogr.Feature(temp_clipped_defn)
            clipped_feature.SetGeometry(clipped_geometry)
            temp_clipped_layer.CreateFeature(clipped_feature)
            clipped_feature = None
        except Exception:
            clipped_feature = None
            LOGGER.warn(
                "Couldn't process this intersection %s",
                intersection_shapely)
    temp_clipped_layer.SyncToDisk()
    temp_clipped_layer = None
    temp_clipped_vector = None

    # # project global clipped polygons to UTM
    # LOGGER.info("reprojecting grid %s", base_shore_point_vector_path)
    # pygeoprocessing.reproject_vector(
    #     temp_clipped_vector_path, utm_spatial_reference.ExportToWkt(),
    #     utm_clipped_vector_path, driver_name='GPKG')

    clipped_geometry_shapely_list = []
    temp_utm_clipped_vector = ogr.Open(temp_clipped_vector_path)
    temp_utm_clipped_layer = temp_utm_clipped_vector.GetLayer()
    for tmp_utm_feature in temp_utm_clipped_layer:
        tmp_utm_geometry = tmp_utm_feature.GetGeometryRef()
        shapely_geometry = shapely.wkb.loads(
            tmp_utm_geometry.ExportToWkb())
        if shapely_geometry.is_valid:
            clipped_geometry_shapely_list.append(shapely_geometry)
        tmp_utm_geometry = None
    temp_utm_clipped_layer = None
    temp_utm_clipped_vector = None
    landmass_shapely = shapely.ops.cascaded_union(
        clipped_geometry_shapely_list)
    clipped_geometry_shapely_list = None

    # load land geometry into shapely object
    landmass_shapely_prep = shapely.prepared.prep(landmass_shapely)

    # explode landmass into lines for easy intersection
    temp_polygon_segements_path = os.path.join(
        workspace_dir, 'polygon_segments.gpkg')
    temp_polygon_segments_vector = esri_shapefile_driver.CreateDataSource(
        temp_polygon_segements_path)
    temp_polygon_segments_layer = (
        temp_polygon_segments_vector.CreateLayer(
            os.path.splitext(os.path.basename(temp_clipped_vector_path))[0],
            base_spatial_reference, ogr.wkbLineString))
    temp_polygon_segments_defn = temp_polygon_segments_layer.GetLayerDefn()

    polygon_line_rtree = rtree.index.Index()
    polygon_line_index = []
    shapely_line_index = []
    line_id = 0
    for line in geometry_to_lines(landmass_shapely):
        segment_feature = ogr.Feature(temp_polygon_segments_defn)
        segement_geometry = ogr.Geometry(ogr.wkbLineString)
        segement_geometry.AddPoint(*line.coords[0])
        segement_geometry.AddPoint(*line.coords[1])
        segment_feature.SetGeometry(segement_geometry)
        temp_polygon_segments_layer.CreateFeature(segment_feature)

        if (line.bounds[0] == line.bounds[2] and
                line.bounds[1] == line.bounds[3]):
            continue
        polygon_line_rtree.insert(line_id, line.bounds)
        line_id += 1
        polygon_line_index.append(segement_geometry)
        shapely_line_index.append(shapely.wkb.loads(
            segement_geometry.ExportToWkb()))

    temp_polygon_segments_layer.SyncToDisk()
    temp_polygon_segments_layer = None
    temp_polygon_segments_vector = None

    # create fetch rays
    temp_fetch_rays_vector = esri_shapefile_driver.CreateDataSource(
        temp_fetch_rays_path)
    temp_fetch_rays_layer = (
        temp_fetch_rays_vector.CreateLayer(
            os.path.splitext(os.path.basename(temp_clipped_vector_path))[0],
            base_spatial_reference, ogr.wkbLineString))
    temp_fetch_rays_defn = temp_fetch_rays_layer.GetLayerDefn()
    temp_fetch_rays_layer.CreateField(ogr.FieldDefn(
        'fetch_dist', ogr.OFTReal))

    target_shore_point_vector = ogr.Open(
        target_fetch_point_vector_path, 1)
    target_shore_point_layer = target_shore_point_vector.GetLayer()
    target_shore_point_layer.CreateField(
        ogr.FieldDefn('REI', ogr.OFTReal))
    for ray_index in range(_N_FETCH_RAYS):
        compass_degree = int(ray_index * 360 / 16.)
        target_shore_point_layer.CreateField(
            ogr.FieldDefn('fdist_%d' % compass_degree, ogr.OFTReal))

    shore_point_logger = _make_logger_callback(
        "Wind exposure %.2f%% complete.", LOGGER)
    # Iterate over every shore point
    for shore_point_feature in target_shore_point_layer:
        shore_point_logger(
            float(shore_point_feature.GetFID()) /
            target_shore_point_layer.GetFeatureCount())
        rei_value = 0.0
        # Iterate over every ray direction
        for sample_index in range(_N_FETCH_RAYS):
            compass_degree = int(sample_index * 360 / 16.)
            compass_theta = float(sample_index) / _N_FETCH_RAYS * 360
            rei_pct = shore_point_feature.GetField(
                'REI_PCT%d' % int(compass_theta))
            rei_v = shore_point_feature.GetField(
                'REI_V%d' % int(compass_theta))
            cartesian_theta = -(compass_theta - 90)

            # Determine the direction the ray will point
            delta_x = math.cos(cartesian_theta * math.pi / 180)
            delta_y = math.sin(cartesian_theta * math.pi / 180)

            shore_point_geometry = shore_point_feature.GetGeometryRef()
            point_a_x = (
                shore_point_geometry.GetX() + delta_x * smallest_feature_size)
            point_a_y = (
                shore_point_geometry.GetY() + delta_y * smallest_feature_size)
            point_b_x = point_a_x + delta_x * (
                max_fetch_distance - smallest_feature_size)
            point_b_y = point_a_y + delta_y * (
                max_fetch_distance - smallest_feature_size)
            shore_point_geometry = None

            # build ray geometry so we can intersect it later
            ray_geometry = ogr.Geometry(ogr.wkbLineString)
            ray_geometry.AddPoint(point_a_x, point_a_y)
            ray_geometry.AddPoint(point_b_x, point_b_y)

            # keep a shapely version of the ray so we can do fast intersection
            # with it and the entire landmass
            ray_point_origin_shapely = shapely.geometry.Point(
                point_a_x, point_a_y)

            ray_length = 0.0
            if not landmass_shapely_prep.intersects(
                    ray_point_origin_shapely):
                # the origin is in ocean

                # This algorithm searches for intersections, if one is found
                # the ray updates and a smaller intersection set is determined
                # by experimentation I've found this is significant, but not
                # an order of magnitude, faster than looping through all
                # original possible intersections.  Since this algorithm
                # will be run for a long time, it's worth the additional
                # complexity
                tested_indexes = set()
                while True:
                    intersection = False
                    ray_envelope = ray_geometry.GetEnvelope()
                    for poly_line_index in polygon_line_rtree.intersection(
                            [ray_envelope[i] for i in [0, 2, 1, 3]]):
                        if poly_line_index in tested_indexes:
                            continue
                        tested_indexes.add(poly_line_index)
                        line_segment = (
                            polygon_line_index[poly_line_index])
                        if ray_geometry.Intersects(line_segment):
                            # if the ray intersects the poly line, test if
                            # the intersection is closer than any known
                            # intersection so far
                            intersection_point = ray_geometry.Intersection(
                                line_segment)
                            # offset the dist with smallest_feature_size
                            # update the endpoint of the ray
                            ray_geometry = ogr.Geometry(ogr.wkbLineString)
                            ray_geometry.AddPoint(point_a_x, point_a_y)
                            ray_geometry.AddPoint(
                                intersection_point.GetX(),
                                intersection_point.GetY())
                            intersection = True
                            break
                    if not intersection:
                        break
                # when we get here `min_point` and `ray_length` are the
                # minimum intersection points for the ray and the landmass
                ray_feature = ogr.Feature(temp_fetch_rays_defn)
                ray_length = ray_geometry.Length()
                ray_feature.SetField('fetch_dist', ray_length)
                ray_feature.SetGeometry(ray_geometry)
                temp_fetch_rays_layer.CreateFeature(ray_feature)
            shore_point_feature.SetField(
                'fdist_%d' % compass_degree, ray_length)
            ray_feature = None
            ray_geometry = None
            rei_value += ray_length * rei_pct * rei_v
        shore_point_feature.SetField('REI', rei_value)
        target_shore_point_layer.SetFeature(shore_point_feature)

    target_shore_point_layer.SyncToDisk()
    target_shore_point_layer = None
    target_shore_point_vector = None
    temp_fetch_rays_layer.SyncToDisk()
    temp_fetch_rays_layer = None
    temp_fetch_rays_vector = None


def build_wwiii_rtree(wwiii_vector_path, wwiii_rtree_path):
    """Build RTree indexed by FID for points in `wwwiii_vector_path`."""
    base_wwiii_rtree_path = os.path.splitext(wwiii_rtree_path)[0]
    if os.path.exists(wwiii_rtree_path):
        for ext in ['.dat', '.idx']:
            os.remove(base_wwiii_rtree_path+ext)
    wwiii_rtree = rtree.index.Index(base_wwiii_rtree_path)

    wwiii_vector = ogr.Open(wwiii_vector_path)
    wwiii_layer = wwiii_vector.GetLayer()
    for wwiii_feature in wwiii_layer:
        wwiii_geometry = wwiii_feature.GetGeometryRef()
        wwiii_x = wwiii_geometry.GetX()
        wwiii_y = wwiii_geometry.GetY()
        wwiii_rtree.insert(
            wwiii_feature.GetFID(), (wwiii_x, wwiii_y, wwiii_x, wwiii_y))
    wwiii_layer = None
    wwiii_vector = None


def build_feature_bounding_box_rtree(vector_path, target_rtree_path):
    """Build an r-tree index of the global feature envelopes.

    Parameter:
        vector_path (string): path to vector to build bounding box index for
        target_rtree_path (string): path to ".dat" file to store the saved
            r-tree.  A ValueError is raised if this file already exists

    Returns:
        None.

    """
    # the input path has a .dat extension, but the `rtree` package only uses
    # the basename.  It's a quirk of the library, so we'll deal with it by
    # cutting off the extension.
    global_feature_index_base = os.path.splitext(
        target_rtree_path)[0]
    LOGGER.info("Building rtree index at %s", global_feature_index_base)
    if os.path.exists(target_rtree_path):
        for ext in ['.dat', '.idx']:
            os.remove(global_feature_index_base + ext)
    global_feature_index = rtree.index.Index(global_feature_index_base)

    global_vector = ogr.Open(vector_path)
    global_layer = global_vector.GetLayer()
    n_features = global_layer.GetFeatureCount()

    logger_callback = _make_logger_callback(
        'rTree construction %.2f%% complete', LOGGER)

    for feature_index, global_feature in enumerate(global_layer):
        feature_geometry = global_feature.GetGeometryRef()
        # format of envelope is [minx, maxx, miny, maxy]
        feature_envelope = feature_geometry.GetEnvelope()
        # format of tree bounding box is [minx, miny, maxx, maxy]
        global_feature_index.insert(
            global_feature.GetFID(), (
                feature_envelope[0], feature_envelope[2],
                feature_envelope[1], feature_envelope[3]))
        logger_callback(float(feature_index) / n_features)
    global_feature_index.close()


def make_shore_kernel(kernel_path):
    """Make a 3x3 raster with a 9 in the middle and 1s on the outside."""
    driver = gdal.GetDriverByName('GTiff')
    kernel_raster = driver.Create(
        kernel_path.encode('utf-8'), 3, 3, 1,
        gdal.GDT_Byte)

    # Make some kind of geotransform, it doesn't matter what but
    # will make GIS libraries behave better if it's all defined
    kernel_raster.SetGeoTransform([0, 1, 0, 0, 0, -1])
    srs = osr.SpatialReference()
    srs.SetWellKnownGeogCS('WGS84')
    kernel_raster.SetProjection(srs.ExportToWkt())

    kernel_band = kernel_raster.GetRasterBand(1)
    kernel_band.SetNoDataValue(127)
    kernel_band.WriteArray(numpy.array([[1, 1, 1], [1, 9, 1], [1, 1, 1]]))

def geometry_to_lines(geometry):
    """Convert a geometry object to a list of lines."""
    if geometry.type == 'Polygon':
        return polygon_to_lines(geometry)
    elif geometry.type == 'MultiPolygon':
        line_list = []
        for geom in geometry.geoms:
            line_list.extend(geometry_to_lines(geom))
        return line_list
    else:
        return []


def polygon_to_lines(geometry):
    """Return a list of shapely lines given higher order shapely geometry."""
    line_list = []
    last_point = geometry.exterior.coords[0]
    for point in geometry.exterior.coords[1::]:
        if point == last_point:
            continue
        line_list.append(shapely.geometry.LineString([last_point, point]))
        last_point = point
    line_list.append(shapely.geometry.LineString([
        last_point, geometry.exterior.coords[0]]))
    for interior in geometry.interiors:
        last_point = interior.coords[0]
        for point in interior.coords[1::]:
            if point == last_point:
                continue
            line_list.append(shapely.geometry.LineString([last_point, point]))
            last_point = point
        line_list.append(shapely.geometry.LineString([
            last_point, interior.coords[0]]))
    return line_list


def _make_logger_callback(message, logger):
    """Build a timed logger callback that prints `message` replaced.

    Parameters:
        message (string): a string that expects a %f replacement variable for
            `proportion_complete`.

    Returns:
        Function with signature:
            logger_callback(proportion_complete, psz_message, p_progress_arg)

    """
    def logger_callback(proportion_complete):
        """Argument names come from the GDAL API for callbacks."""
        try:
            current_time = time.time()
            if ((current_time - logger_callback.last_time) > 5.0 or
                    (proportion_complete == 1.0 and
                     logger_callback.total_time >= 5.0)):
                LOGGER.info(message, proportion_complete * 100)
                logger_callback.last_time = current_time
                logger_callback.total_time += current_time
        except AttributeError:
            logger_callback.last_time = time.time()
            logger_callback.total_time = 0.0

    return logger_callback
"""InVEST Coastal Vulnerability"""
import sys
import traceback
import shutil
import time
import os
import math
import logging
import re
import multiprocessing
import zipfile

import numpy
from osgeo import gdal
from osgeo import osr
from osgeo import ogr
import rtree
import shapely
import shapely.wkb
import shapely.ops
import shapely.speedups
import pygeoprocessing

LOGGER = logging.getLogger(__name__)

# Wave Watch III data does not cover the planet.  Make sure we don't deal
# with a point that's not in range of said point.  I'm picking 1 degree since
# that's double the diagonal distance between two WWIII points
_MAX_WWIII_DISTANCE = 5.0 # RICH: did you later decide 5 degree is better choice than 1?

def build_wwiii_rtree(wwiii_vector_path, wwiii_rtree_path):
    """Build RTree indexed by FID for points in `wwwiii_vector_path`."""
    base_wwiii_rtree_path = os.path.splitext(wwiii_rtree_path)[0]
    if os.path.exists(wwiii_rtree_path):
        for ext in ['.dat', '.idx']:
            os.remove(base_wwiii_rtree_path+ext)
    wwiii_rtree = rtree.index.Index(base_wwiii_rtree_path)

    wwiii_vector = ogr.Open(wwiii_vector_path)
    wwiii_layer = wwiii_vector.GetLayer()
    for wwiii_feature in wwiii_layer:
        wwiii_geometry = wwiii_feature.GetGeometryRef()
        wwiii_x = wwiii_geometry.GetX()
        wwiii_y = wwiii_geometry.GetY()
        wwiii_rtree.insert(
            wwiii_feature.GetFID(), (wwiii_x, wwiii_y, wwiii_x, wwiii_y))
    wwiii_layer = None
    wwiii_vector = None


def create_shore_points(
        landmass_vector_path, wwiii_vector_path, wwiii_rtree_path,
        smallest_feature_size,
        workspace_dir, target_shore_point_vector_path):
    """Create points that lie on the coast line of the landmass.

    Also join tabular data from Wave Watch 3 to shore points by finding the
    nearest WW3 points to each shore point.

    Parameters:
        landmass_vector_path (string): path to polygon vector representing
            landmass.
        wwiii_vector_path (string): path to point shapefile representing
            the Wave Watch III data.
        wwiii_rtree_path (string): path to an rtree index that has
            the points of `wwiii_vector_path` indexed.
        smallest_feature_size (float): smallest feature size to grid a shore
            point on.
        workspace_dir (string): path to a directory that can be created
            during run to hold temporary files.  Will be deleted on successful
            function completion.
        target_shore_point_vector_path (string): path to a point vector that
            will be created and contain points on the shore of the landmass.

    Returns:
        None.

    """
    # LOGGER.info("Creating shore points for grid %s", grid_fid)
    # create the spatial reference from the base vector
    landmass_spatial_reference = osr.SpatialReference()
    landmass_spatial_reference.ImportFromWkt(
        pygeoprocessing.get_vector_info(landmass_vector_path)['projection'])
    wwiii_spatial_reference = osr.SpatialReference()
    wwiii_spatial_reference.ImportFromWkt(
        pygeoprocessing.get_vector_info(wwiii_vector_path)['projection'])

    # if os.path.exists(workspace_dir):
    #     shutil.rmtree(workspace_dir)
    # os.makedirs(workspace_dir)

    lat_lng_clipped_vector_path = os.path.join(
        workspace_dir, 'clipped_geometry_lat_lng.gpkg')
    grid_raster_path = os.path.join(workspace_dir, 'grid.tif')
    convolution_raster_path = os.path.join(
        workspace_dir, 'convolution.tif')
    utm_clipped_vector_path = os.path.join(
        workspace_dir, 'clipped_geometry_utm.gpkg')
    shore_kernel_path = os.path.join(
        workspace_dir, 'shore_kernel.tif')
    shore_raster_path = os.path.join(
        workspace_dir, 'shore_raster.tif')

    for path in [target_shore_point_vector_path,
                 lat_lng_clipped_vector_path,
                 grid_raster_path]:
        if os.path.exists(path):
            os.remove(path)

    esri_shapefile_driver = ogr.GetDriverByName("ESRI Shapefile")

    # # this will hold the clipped landmass geometry
    # lat_lng_clipped_vector = esri_shapefile_driver.CreateDataSource(
    #     lat_lng_clipped_vector_path)
    # lat_lng_clipped_layer = (
    #     lat_lng_clipped_vector.CreateLayer(
    #         os.path.splitext(lat_lng_clipped_vector_path)[0],
    #         landmass_spatial_reference, ogr.wkbPolygon))
    # lat_lng_clipped_defn = lat_lng_clipped_layer.GetLayerDefn()

    # this will hold the output sample points on the shore
    target_shore_point_vector = esri_shapefile_driver.CreateDataSource(
        target_shore_point_vector_path)
    target_shore_point_layer = target_shore_point_vector.CreateLayer(
        os.path.splitext(target_shore_point_vector_path)[0],
        landmass_spatial_reference, ogr.wkbPoint)

    wwiii_vector = ogr.Open(wwiii_vector_path)
    wwiii_layer = wwiii_vector.GetLayer()
    wwiii_defn = wwiii_layer.GetLayerDefn()
    field_names = []
    for field_index in range(wwiii_defn.GetFieldCount()):
        field_defn = wwiii_defn.GetFieldDefn(field_index)
        field_name = field_defn.GetName()
        if field_name in ['I', 'J']:
            continue
        field_names.append(field_name)
        target_shore_point_layer.CreateField(field_defn)
    target_shore_point_defn = target_shore_point_layer.GetLayerDefn()

    landmass_vector = ogr.Open(landmass_vector_path)
    landmass_layer = landmass_vector.GetLayer()

    # grid_vector = ogr.Open(sample_grid_vector_path)
    # grid_layer = grid_vector.GetLayer()
    # grid_feature = grid_layer.GetFeature(grid_fid)
    # grid_geometry_ref = grid_feature.GetGeometryRef()
    # grid_shapely = shapely.wkb.loads(grid_geometry_ref.ExportToWkb())

    # landmass_vector_rtree = rtree.index.Index(
    #     os.path.splitext(landmass_bounding_rtree_path)[0])

    # project global polygon clip to UTM
    # transform lat/lng box to utm -> local box
    # utm_spatial_reference = get_utm_spatial_reference(grid_shapely.bounds)
    # utm_bounding_box = pygeoprocessing.transform_bounding_box(
    #     grid_shapely.bounds, landmass_spatial_reference.ExportToWkt(),
    #     utm_spatial_reference.ExportToWkt(), edge_samples=11)

    # # add a pixel buffer so we clip land that's a little outside the grid
    # pixel_buffer = 1
    # utm_bounding_box[0] -= pixel_buffer * smallest_feature_size
    # utm_bounding_box[1] -= pixel_buffer * smallest_feature_size
    # utm_bounding_box[2] += pixel_buffer * smallest_feature_size
    # utm_bounding_box[3] += pixel_buffer * smallest_feature_size

    # # transform local box back to lat/lng -> global clipping box
    # lat_lng_clipping_box = pygeoprocessing.transform_bounding_box(
    #     utm_bounding_box, utm_spatial_reference.ExportToWkt(),
    #     landmass_spatial_reference.ExportToWkt(), edge_samples=11)
    # # see if we're wrapped on the dateline
    # if (grid_shapely.bounds[0] > 0 and
    #         lat_lng_clipping_box[0] > lat_lng_clipping_box[2]):
    #     lat_lng_clipping_box[2] += 360
    # elif (grid_shapely.bounds[0] < 0 and
    #       lat_lng_clipping_box[0] > lat_lng_clipping_box[2]):
    #     lat_lng_clipping_box[0] -= 360
    # lat_lng_clipping_shapely = shapely.geometry.box(*lat_lng_clipping_box)

    # # clip global polygon to utm clipping box
    # LOGGER.info(
    #     "clip global polygon to utm clipping box for grid %s", grid_fid)
    # for feature_id in landmass_vector_rtree.intersection(
    #         lat_lng_clipping_box):
    #     try:
    #         base_feature = landmass_layer.GetFeature(feature_id)
    #         base_geometry = base_feature.GetGeometryRef()
    #         base_shapely = shapely.wkb.loads(base_geometry.ExportToWkb())
    #         base_geometry = None
    #         intersection_shapely = lat_lng_clipping_shapely.intersection(
    #             base_shapely)
    #         target_geometry = ogr.CreateGeometryFromWkt(
    #             intersection_shapely.wkt)
    #         target_feature = ogr.Feature(lat_lng_clipped_defn)
    #         target_feature.SetGeometry(target_geometry)
    #         lat_lng_clipped_layer.CreateFeature(target_feature)
    #         target_feature = None
    #         target_geometry = None
    #     except shapely.errors.WKBReadingError:
    #         LOGGER.error("couldn't read fid %d for some reason.", feature_id)
    #     except Exception:
    #         LOGGER.warn(
    #             "Couldn't process this intersection %s",
    #             intersection_shapely)
    # lat_lng_clipped_layer.SyncToDisk()
    # lat_lng_clipped_layer = None
    # lat_lng_clipped_vector = None

    # # create grid for underlying local utm box
    # pygeoprocessing.reproject_vector(
    #     lat_lng_clipped_vector_path, utm_spatial_reference.ExportToWkt(),
    #     utm_clipped_vector_path, driver_name='GPKG')

    byte_nodata = 255

    utm_clipped_vector_path = landmass_vector_path
    pygeoprocessing.create_raster_from_vector_extents(
        utm_clipped_vector_path,
        grid_raster_path, (
            smallest_feature_size / 2.0, -smallest_feature_size / 2.0),
        gdal.GDT_Byte, byte_nodata, fill_value=0)

    # rasterize utm global clip to grid
    pygeoprocessing.rasterize(
        utm_clipped_vector_path, grid_raster_path, [1], None)

    # grid shoreline from raster
    make_shore_kernel(shore_kernel_path)
    pygeoprocessing.convolve_2d(
        (grid_raster_path, 1), (shore_kernel_path, 1),
        convolution_raster_path, target_datatype=gdal.GDT_Byte,
        target_nodata=255)

    temp_grid_nodata = pygeoprocessing.get_raster_info(
        grid_raster_path)['nodata'][0]

    def _shore_mask_op(shore_convolution):
        """Mask values on land that border water."""
        result = numpy.empty(shore_convolution.shape, dtype=numpy.uint8)
        result[:] = byte_nodata
        valid_mask = shore_convolution != temp_grid_nodata
        # If a pixel is on land, it gets at least a 9, but if it's all on
        # land it gets an 17 (8 neighboring pixels), so we search between 9
        # and 17 to determine a shore pixel
        result[valid_mask] = numpy.where(
            (shore_convolution[valid_mask] >= 9) &
            (shore_convolution[valid_mask] < 17), 1, byte_nodata)
        return result

    pygeoprocessing.raster_calculator(
        [(convolution_raster_path, 1)], _shore_mask_op,
        shore_raster_path, gdal.GDT_Byte, byte_nodata)

    shore_geotransform = pygeoprocessing.get_raster_info(
        shore_raster_path)['geotransform']

    landmass_to_wwiii_transform = osr.CoordinateTransformation(
        landmass_spatial_reference, wwiii_spatial_reference)
    # rtree index loads without the extension
    wwiii_rtree_base_path = os.path.splitext(
        wwiii_rtree_path)[0]
    wwiii_rtree = rtree.index.Index(wwiii_rtree_base_path)
    wwiii_field_lookup = {}

    # LOGGER.info(
    #     "Interpolating shore points with Wave Watch III data for grid %s",
    #     grid_fid)
    feature_lookup = {}
    for offset_info, data_block in pygeoprocessing.iterblocks(
            (shore_raster_path, 1)):
        row_indexes, col_indexes = numpy.mgrid[
            offset_info['yoff']:offset_info['yoff']+offset_info['win_ysize'],
            offset_info['xoff']:offset_info['xoff']+offset_info['win_xsize']]
        valid_mask = data_block == 1
        x_coordinates = (
            shore_geotransform[0] +
            shore_geotransform[1] * (col_indexes[valid_mask] + 0.5) +
            shore_geotransform[2] * (row_indexes[valid_mask] + 0.5))
        y_coordinates = (
            shore_geotransform[3] +
            shore_geotransform[4] * (col_indexes[valid_mask] + 0.5) +
            shore_geotransform[5] * (row_indexes[valid_mask] + 0.5))

        for x_coord, y_coord in zip(x_coordinates, y_coordinates):
            # Set the point geometry in the native SRS
            shore_point_geometry = ogr.Geometry(ogr.wkbPoint)
            shore_point_geometry.AddPoint(x_coord, y_coord)
            shore_point_feature = ogr.Feature(target_shore_point_defn)
            shore_point_feature.SetGeometry(shore_point_geometry)
            
            # Then transform point to match the wwiii SRS to find nearest
            shore_point_geometry.Transform(landmass_to_wwiii_transform)
            # get the nearest wave watch III points from the shore point
            nearest_points = list(wwiii_rtree.nearest(
                (shore_point_geometry.GetX(),
                 shore_point_geometry.GetY(),
                 shore_point_geometry.GetX(),
                 shore_point_geometry.GetY()), 3))[0:3]

            # create placeholders for point geometry and field values
            wwiii_points = numpy.empty((3, 2))
            wwiii_values = numpy.empty((3, len(field_names)))
            for fid_index, fid in enumerate(nearest_points):
                wwiii_feature = wwiii_layer.GetFeature(fid)
                wwiii_geometry = wwiii_feature.GetGeometryRef()
                wwiii_points[fid_index] = numpy.array(
                    [wwiii_geometry.GetX(), wwiii_geometry.GetY()])
                try:
                    wwiii_values[fid_index] = wwiii_field_lookup[fid]
                except KeyError:
                    wwiii_field_lookup[fid] = numpy.array(
                        [float(wwiii_feature.GetField(field_name))
                         for field_name in field_names])
                    wwiii_values[fid_index] = wwiii_field_lookup[fid]
            # import pdb; pdb.set_trace()
            distance = numpy.linalg.norm(
                wwiii_points - numpy.array(
                    (shore_point_geometry.GetX(),
                     shore_point_geometry.GetY())))

            # make sure we're within a valid data distance
            if distance > _MAX_WWIII_DISTANCE:
                continue

            wwiii_values *= distance
            wwiii_values = numpy.mean(wwiii_values, axis=0)
            wwiii_values /= numpy.sum(distance)

            for field_name_index, field_name in enumerate(field_names):
                shore_point_feature.SetField(
                    field_name, wwiii_values[field_name_index])

            target_shore_point_layer.CreateFeature(shore_point_feature)
            shore_point_feature = None
    del feature_lookup
    # LOGGER.info("All done with shore points for grid %s", grid_fid)


def make_shore_kernel(kernel_path):
    """Make a 3x3 raster with a 9 in the middle and 1s on the outside."""
    driver = gdal.GetDriverByName('GTiff')
    kernel_raster = driver.Create(
        kernel_path.encode('utf-8'), 3, 3, 1,
        gdal.GDT_Byte)

    # Make some kind of geotransform, it doesn't matter what but
    # will make GIS libraries behave better if it's all defined
    kernel_raster.SetGeoTransform([0, 1, 0, 0, 0, -1])
    srs = osr.SpatialReference()
    srs.SetWellKnownGeogCS('WGS84')
    kernel_raster.SetProjection(srs.ExportToWkt())

    kernel_band = kernel_raster.GetRasterBand(1)
    kernel_band.SetNoDataValue(127)
    kernel_band.WriteArray(numpy.array([[1, 1, 1], [1, 9, 1], [1, 1, 1]]))

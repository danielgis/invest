# -*- coding: utf-8 -*-
"""Coastal Blue Carbon Model."""

import csv
import os
import pprint as pp
import shutil
import logging
import numpy as np

import pygeoprocessing.geoprocessing as geoprocess

from natcap.invest.coastal_blue_carbon import io, utils

logging.basicConfig(format='%(asctime)s %(name)-20s %(levelname)-8s \
%(message)s', level=logging.DEBUG, datefmt='%m/%d/%Y %H:%M:%S ')
LOGGER = logging.getLogger('natcap.invest.coastal_blue_carbon.coastal_blue_carbon')


def execute(args):
    """Entry point for Coastal Blue Carbon model.

    :param str args['workspace_dir']: location into which all intermediate and
        output files should be placed.

    :param str args['results_suffix']: a string to append to output filenames.

    :param str args['lulc_lookup_uri']: filepath to a CSV table used to convert
        the lulc code to a name. Also used to determine if a given lulc type is
        a coastal blue carbon habitat.

    :param str args['lulc_transition_matrix_uri']: generated by the
        preprocessor. This file must be edited before it can be used by the main
        model. The left-most column represents the source lulc class, and the
        top row represents the destination lulc class.

    :param str args['carbon_pool_initial_uri']: the provided CSV table contains
        information related to the initial conditions of the carbon stock within
        each of the three pools of a habitat. Biomass includes carbon stored
        above and below ground. All non-coastal blue carbon habitat lulc
        classes are assumed to contain no carbon. The values for 'biomass',
        'soil', and 'litter' should be given in terms of Megatonnes CO2 e/ ha.

    :param str args['carbon_pool_transient_uri']: the provided CSV table
        contains information related to the transition of carbon into and out
        of coastal blue carbon pools. All non-coastal blue carbon habitat lulc
        classes are assumed to neither sequester nor emit carbon as a result of
        change. The ‘yearly_accumulation’ values should be given in terms of
        Megatonnes of CO2 e/ha-yr. The ‘half-life’ values must be given in terms
        of years. The ‘disturbance’ values must be given as a decimal percentage
        of stock distrubed given a transition occurs away from a lulc-class.

    :param str args['lulc_baseline_map_uri']: a GDAL-supported raster
        representing the baseline landscape/seascape.

    :param list args['lulc_transition_maps_list']: a list of GDAL-supported
        rasters representing the landscape/seascape at particular points in
        time. Provided in chronological order.

    :param list args['lulc_transition_years_list']: a list of years that
        respectively correspond to transition years of the rasters. Provided in
        chronological order.

    :param int args['analysis_year']: optional. Indicates how many timesteps to
        run the transient analysis beyond the last transition year. Must come
        chronologically after the last transition year if provided. Otherwise,
        the final timestep of the model will be set to the last transition year.

    :param bool args['do_economic_analysis']: boolean value indicating whether
        model should run economic analysis.

    :param bool args['do_price_table']: boolean value indicating whether a price
        table is included in the arguments and to be used or a price and
        interest rate is provided and to be used instead.

    :param float args['price']: the price per Megatonne CO2 e at the base year.

    :param float args['interest_rate']: the interest rate on the price per
        Megatonne CO2 e, compounded yearly.

    :param bool args['price_table_uri']: If `args['do_price_table']` is set to
        `True` the provided CSV table is used in place of price and interest
        rate inputs. The table contains the price per Megatonne CO2e sequestered
        for a given year, for all years from the original snapshot to the
        analysis year, if provided.

    :param bool args['discount_rate']: the discount rate on future valuations of
        sequestered carbon, compounded yearly.

    Example Args::

        args = {
            'workspace_dir': 'path/to/workspace/',
            'results_suffix': '',
            'lulc_lookup_uri': 'path/to/lulc_lookup_uri',
            'lulc_transition_matrix_uri': 'path/to/lulc_transition_uri',
            'carbon_pool_initial_uri': 'path/to/carbon_pool_initial_uri',
            'carbon_pool_transient_uri': 'path/to/carbon_pool_transient_uri',
            'lulc_baseline_map_uri': 'path/to/baseline_map.tif',
            'lulc_transition_maps_list': [raster1_uri, raster2_uri, ...],
            'lulc_transition_years_list': [2000, 2005, ...],
            'analysis_year': 2100,
            'do_economic_analysis': '<boolean>',
            'do_price_table': '<boolean>',
            'price': '<float>',
            'interest_rate': '<float>',
            'price_table_uri': 'path/to/price_table',
            'discount_rate': '<float>'
        }
    """
    LOGGER.info("Starting model run...")
    d = io.get_inputs(args)
    run(d)
    LOGGER.info("...Model run complete.")


def run(d):
    block_iterator = geoprocess.iterblocks(d.C_prior_raster)
    for offset_dict, _ in block_iterator:
        # Initialization
        C_prior = utils.read_from_raster(d.C_prior_raster, offset_dict)
        C_r = [utils.read_from_raster(i, offset_dict) for i in d.C_r_rasters]
        timesteps = d.timesteps
        transitions = d.transitions

        x_size = len(C_prior)
        y_size = len(C_prior[0])

        S_biomass = np.zeros((timesteps+1, x_size, y_size))
        S_soil    = np.zeros((timesteps+1, x_size, y_size))
        S_litter  = np.zeros((timesteps+1, x_size, y_size))
        T         = np.zeros((timesteps+1, x_size, y_size))
        A_biomass = np.zeros((timesteps, x_size, y_size))
        A_soil    = np.zeros((timesteps, x_size, y_size))
        E_biomass = np.zeros((timesteps, x_size, y_size))
        E_soil    = np.zeros((timesteps, x_size, y_size))
        N_biomass = np.zeros((timesteps, x_size, y_size))
        N_soil    = np.zeros((timesteps, x_size, y_size))
        V         = np.zeros((timesteps, x_size, y_size))
        P         = np.zeros((timesteps, x_size, y_size))

        L         = np.zeros((transitions, x_size, y_size))
        Y_biomass = np.zeros((transitions, x_size, y_size))
        Y_soil    = np.zeros((transitions, x_size, y_size))
        D_biomass = np.zeros((transitions, x_size, y_size))
        D_soil    = np.zeros((transitions, x_size, y_size))
        H_biomass = np.zeros((transitions, x_size, y_size))
        H_soil    = np.zeros((transitions, x_size, y_size))
        R_biomass = np.zeros((transitions, x_size, y_size))
        R_soil    = np.zeros((transitions, x_size, y_size))

        # Set Accum and Disturbance Values
        for i in xrange(0, transitions):
            if i == 0:
                D_biomass[i] = utils.reclass_transition(C_prior, C_r[0], d.lulc_trans_to_Db, out_dtype=np.float32)
                D_soil[i]    = utils.reclass_transition(C_prior, C_r[0], d.lulc_trans_to_Ds, out_dtype=np.float32)
                H_biomass[i] = utils.reclass(C_prior, d.lulc_to_Hb, out_dtype=np.float32)
                H_soil[i]    = utils.reclass(C_prior, d.lulc_to_Hs, out_dtype=np.float32)
            else:
                D_biomass[i] = utils.reclass_transition(C_r[i-1], C_r[i], d.lulc_trans_to_Db, out_dtype=np.float32)
                D_soil[i]    = utils.reclass_transition(C_r[i-1], C_r[i], d.lulc_trans_to_Ds, out_dtype=np.float32)
                H_biomass[i] = utils.reclass(C_r[i-1], d.lulc_to_Hb, out_dtype=np.float32)
                H_soil[i]    = utils.reclass(C_r[i-1], d.lulc_to_Hs, out_dtype=np.float32)

            L[i]         = utils.reclass(C_r[i], d.lulc_to_L, out_dtype=np.float32)
            Y_biomass[i] = utils.reclass(C_r[i], d.lulc_to_Yb, out_dtype=np.float32)
            Y_soil[i]    = utils.reclass(C_r[i], d.lulc_to_Ys, out_dtype=np.float32)

        S_biomass[0] = utils.reclass(C_prior, d.lulc_to_Sb, out_dtype=np.float32)
        S_soil[0]    = utils.reclass(C_prior, d.lulc_to_Ss, out_dtype=np.float32)
        S_litter[0]  = utils.reclass(C_prior, d.lulc_to_L, out_dtype=np.float32)
        T[0]         = S_biomass[0] + S_soil[0] + S_litter[0]

        R_biomass[0] = D_biomass[0] * S_biomass[0]
        R_soil[0]    = D_soil[0] * S_soil[0]

        # Transient Analysis
        for i in range(0, timesteps):
            transition_idx = timestep_to_transition_idx(d, i)

            if is_transition_year(d, i):
                # Set disturbed stock values
                R_biomass[transition_idx] = D_biomass[transition_idx] * S_biomass[i]
                R_soil[transition_idx] = D_soil[transition_idx] * S_soil[i]

            # Accumulation
            A_biomass[i] = Y_biomass[transition_idx]
            A_soil[i] = Y_soil[transition_idx]

            # Emissions
            E_biomass[i] = np.zeros(A_biomass[0].shape)
            E_soil[i] = np.zeros(A_biomass[0].shape)
            for transition_idx in xrange(0, timestep_to_transition_idx(d, i)+1):
                j = transition_idx_to_timestep(d, transition_idx)
                E_biomass[i] += R_biomass[transition_idx] * (0.5**(i-j) - 0.5**(i-j+1))
                E_soil[i] += R_soil[transition_idx] * (0.5**(i-j) - 0.5**(i-j+1))

            # Net Sequestration
            N_biomass[i] = A_biomass[i] - E_biomass[i]
            N_soil[i] = A_soil[i] - E_soil[i]

            # Next Stock
            S_biomass[i+1] = S_biomass[i] + N_biomass[i]
            S_soil[i+1] = S_soil[i] + N_soil[i]
            T[i+1] = S_biomass[i+1] + S_soil[i+1] + S_litter[i+1]

            # Net Present Value
            if d.do_economic_analysis:
                V[i] = (N_biomass[i] + N_soil[0]) * d.price_t[i]

        # Write outputs: T_s, A_r, E_r, N_r, NPV
        T_s = [T[snapshot_idx_to_timestep(d, i)] for i in range(0, len(d.snapshot_years))]
        A = A_biomass + A_soil
        A_r = [sum(A[snapshot_idx_to_timestep(d, i):snapshot_idx_to_timestep(d, i+1)]) for i in range(0, len(d.snapshot_years)-1)]
        E = E_biomass + E_soil
        E_r = [sum(E[snapshot_idx_to_timestep(d, i):snapshot_idx_to_timestep(d, i+1)]) for i in range(0, len(d.snapshot_years)-1)]
        N = N_biomass + N_soil
        N_r = [sum(N[snapshot_idx_to_timestep(d, i):snapshot_idx_to_timestep(d, i+1)]) for i in range(0, len(d.snapshot_years)-1)]
        N_total = sum(N)

        for i in range(0, len(d.T_s_rasters)):
            utils.write_to_raster(d.T_s_rasters[i], T_s[i], offset_dict['xoff'], offset_dict['yoff'])

        for i in range(0, len(d.A_r_rasters)):
            utils.write_to_raster(d.A_r_rasters[i], A_r[i], offset_dict['xoff'], offset_dict['yoff'])

        for i in range(0, len(d.E_r_rasters)):
            utils.write_to_raster(d.E_r_rasters[i], E_r[i], offset_dict['xoff'], offset_dict['yoff'])

        for i in range(0, len(d.N_r_rasters)):
            utils.write_to_raster(d.N_r_rasters[i], N_r[i], offset_dict['xoff'], offset_dict['yoff'])

        utils.write_to_raster(d.N_total_raster, N_total, offset_dict['xoff'], offset_dict['yoff'])

        if d.do_economic_analysis:
            NPV = np.sum(V[:], axis=0)
            utils.write_to_raster(d.NPV_raster, NPV, offset_dict['xoff'], offset_dict['yoff'])


def timestep_to_transition_idx(d, timestep):
    """Convert timestep to transition index."""
    for i in xrange(0, d.transitions):
        if timestep < (d.snapshot_years[i+1] - d.snapshot_years[0]):
            return i
    return None


def snapshot_idx_to_timestep(d, snapshot_idx):
    """Convert snapshot_idx to timestep."""
    return d.snapshot_years[snapshot_idx] - d.snapshot_years[0]


def is_transition_year(d, timestep):
    """Check whether given timestep is a transition year."""
    if (timestep_to_transition_idx(d, timestep) != timestep_to_transition_idx(d, timestep-1) and
        timestep_to_transition_idx(d, timestep)):
        return True
    return False


def transition_idx_to_timestep(d, transition_idx):
    """Convert transition_idx to timestep."""
    return d.transition_years[transition_idx] - d.transition_years[0]

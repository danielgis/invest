"""Module for Regression Testing the InVEST Coastal Vulnerability module."""
import unittest
import tempfile
import shutil
import os
import pickle

from osgeo import gdal, osr
import numpy.testing
import pandas.testing
# import pygeoprocessing.testing
from pygeoprocessing.testing import sampledata
from shapely.geometry import Point
import taskgraph

REGRESSION_DATA = os.path.join(
    os.path.dirname(__file__), '..', 'data', 'invest-test-data',
    'coastal_vulnerability')
INPUT_DATA = os.path.join(
    os.path.dirname(__file__), '..', 'data', 'invest-test-data',
    'coastal_vulnerability', 'input')
TEST_WORKSPACE_DIR = "../invest_dev/coastal_vulnerability/test_workspace"


class CoastalVulnerabilityTests(unittest.TestCase):
    """Tests for the Coastal Vulnerability Model."""

    def setUp(self):
        """Overriding setUp function to create temp workspace directory."""
        # this lets us delete the workspace after its done no matter the
        # the rest result
        self.workspace_dir = tempfile.mkdtemp()

    def tearDown(self):
        """Overriding tearDown function to remove temporary directory."""
        shutil.rmtree(self.workspace_dir)

    @unittest.skip("skip shore points")
    def test_shore_points(self):
        from natcap.invest import coastal_vulnerability

        # workspace_dir = self.workspace_dir
        workspace_dir = os.path.join(TEST_WORKSPACE_DIR, "shore_points")
        aoi_vector_path = os.path.join(INPUT_DATA, 'AOI_BarkClay.shp')
        landmass_vector_path = os.path.join(
            INPUT_DATA, "land_polygon_simple_utm.shp")
        smallest_feature_size = 5000
        target_shore_point_vector_path = os.path.join(
            workspace_dir, "shore_points_%sm.gpkg" % str(smallest_feature_size))
        file_suffix = ''

        coastal_vulnerability.create_shore_points(
            aoi_vector_path, landmass_vector_path,
            smallest_feature_size, workspace_dir, file_suffix,
            target_shore_point_vector_path)

    # @unittest.skip("skip wind and ray")
    def test_wind_and_wave_exposure(self):
        from natcap.invest import coastal_vulnerability

        # workspace_dir = self.workspace_dir
        workspace_dir = os.path.join(TEST_WORKSPACE_DIR, "wind_wave")
        base_shore_point_vector_path = os.path.join(
            INPUT_DATA, "wwiii_shore_points_5000m.gpkg")
        target_fetch_point_vector_path = os.path.join(
            workspace_dir, 'fetch_points.gpkg')
        landmass_polygon_pickle_path = os.path.join(
            INPUT_DATA, "landmass_polygon_5000m.pickle")
        landmass_line_rtree_path = os.path.join(
            INPUT_DATA, "landmass_line_rtree_5000m.dat")
        landmass_lines_pickle_path = os.path.join(
            INPUT_DATA, "landmass_line_index_5000m.pickle")
        file_suffix = ''
        model_resolution = 5000
        max_fetch_distance = 12000
        target_wind_exposure_pickle_path = os.path.join(
            workspace_dir, 'wind.pickle')

        coastal_vulnerability.calculate_wind_exposure(
            base_shore_point_vector_path,
            landmass_polygon_pickle_path,
            landmass_line_rtree_path,
            landmass_lines_pickle_path,
            workspace_dir, file_suffix,
            model_resolution, max_fetch_distance,
            target_fetch_point_vector_path,
            target_wind_exposure_pickle_path)

        expected_raw_values_path = os.path.join(
            REGRESSION_DATA, 'expected_wind.pickle')
        assert_pickle_arrays_almost_equal(
            target_wind_exposure_pickle_path, expected_raw_values_path)

        target_wave_exposure_pickle_path = os.path.join(
            workspace_dir, 'wave.pickle')
        coastal_vulnerability.calculate_wave_exposure(
            target_fetch_point_vector_path, max_fetch_distance,
            target_wave_exposure_pickle_path)

        expected_raw_values_path = os.path.join(
            REGRESSION_DATA, 'expected_wave.pickle')
        assert_pickle_arrays_almost_equal(
            target_wave_exposure_pickle_path, expected_raw_values_path)

    # @unittest.skip("skip habitat")
    def test_habitat_rank(self):
        from natcap.invest import coastal_vulnerability

        # workspace_dir = self.workspace_dir
        workspace_dir = os.path.join(TEST_WORKSPACE_DIR, 'habitat_dir')
        base_shore_point_vector_path = os.path.join(
            INPUT_DATA, "wwiii_shore_points_5000m.gpkg")
        habitat_table_path = os.path.join(
            INPUT_DATA, "natural_habitats_wcvi.csv")
        target_habitat_protection_path = os.path.join(
            workspace_dir, 'habitat_protection.csv')
        file_suffix = ''

        task_graph = taskgraph.TaskGraph(
            os.path.join(workspace_dir, 'taskgraph_dir'), -1)

        task_list, pickle_list = coastal_vulnerability._schedule_habitat_tasks(
            base_shore_point_vector_path, habitat_table_path,
            workspace_dir, file_suffix, task_graph)

        coastal_vulnerability.calculate_habitat_rank(
            pickle_list, target_habitat_protection_path)

        expected_habitat_path = os.path.join(
            REGRESSION_DATA, 'expected_habitat_protection.csv')
        actual_values_df = pandas.read_csv(target_habitat_protection_path)
        expected_values_df = pandas.read_csv(expected_habitat_path)
        pandas.testing.assert_frame_equal(actual_values_df, expected_values_df)

    # @unittest.skip("skip geomorphology")
    def test_geomorphology_rank(self):
        from natcap.invest import coastal_vulnerability

        # workspace_dir = self.workspace_dir
        workspace_dir = os.path.join(TEST_WORKSPACE_DIR, 'geomorphology')
        geomorphology_vector_path = os.path.join(
            INPUT_DATA, "geomorphology_few_ranks.shp")
        base_shore_point_vector_path = os.path.join(
            INPUT_DATA, "wwiii_shore_points_5000m.gpkg")
        target_pickle_path = os.path.join(
            workspace_dir, 'geomorphology.pickle')
        file_suffix = ''
        model_resolution = 5000

        coastal_vulnerability.calculate_geomorphology_exposure(
            geomorphology_vector_path, 3,
            base_shore_point_vector_path,
            model_resolution,
            workspace_dir, file_suffix,
            target_pickle_path)

        target_raw_values_path = os.path.join(
            workspace_dir, 'geomorphology.pickle')
        with open(target_raw_values_path, 'rb') as pickle_file:
            actual_values_dict = pickle.load(pickle_file)
        actual_values = actual_values_dict.values()

        expected_raw_values_path = os.path.join(
            REGRESSION_DATA, 'expected_geomorphology.pickle')
        with open(expected_raw_values_path, 'rb') as pickle_file:
            expected_values_dict = pickle.load(pickle_file)
        expected_values = expected_values_dict.values()

        numpy.testing.assert_array_equal(actual_values, expected_values)

    # @unittest.skip("skip surge")
    def test_surge_exposure_rank(self):
        from natcap.invest import coastal_vulnerability

        base_shore_point_vector_path = os.path.join(
            INPUT_DATA, "wwiii_shore_points_5000m.gpkg")
        shelf_contour_path = os.path.join(
            INPUT_DATA, 'continental_shelf_contour.gpkg') # a polyline
        aoi_vector_path = os.path.join(INPUT_DATA, 'AOI_BarkClay.shp')
        workspace_dir = os.path.join(TEST_WORKSPACE_DIR, 'surge')
        target_surge_pickle_path = os.path.join(workspace_dir, 'surge.pickle')

        coastal_vulnerability.calculate_surge_exposure(
            base_shore_point_vector_path, shelf_contour_path, aoi_vector_path,
            target_surge_pickle_path)

        expected_raw_values_path = os.path.join(
            REGRESSION_DATA, 'expected_surge.pickle')

        # TODO: also assert that keys match, so far only checking values
        assert_pickle_arrays_almost_equal(
            target_surge_pickle_path, expected_raw_values_path)


    # @unittest.skip("skip relief")
    def test_relief_values(self):
        from natcap.invest import coastal_vulnerability

        base_shore_point_vector_path = os.path.join(
            INPUT_DATA, "wwiii_shore_points_5000m.gpkg")
        global_dem_path = os.path.join(
            "../invest-sample-data/Base_Data/Marine/DEMs/global_dem/", "hdr.adf")
        workspace_dir = os.path.join(TEST_WORKSPACE_DIR, 'relief')
        target_relief_pickle_path = os.path.join(workspace_dir, 'relief.pickle')
        dem_averaging_radius = 20000.0
        model_resolution = 5000
        file_suffix = ''

        coastal_vulnerability.calculate_relief_exposure(
            base_shore_point_vector_path, global_dem_path, dem_averaging_radius,
            model_resolution, workspace_dir, file_suffix,
            target_relief_pickle_path)

        expected_raw_values_path = os.path.join(
            REGRESSION_DATA, 'expected_relief.pickle')

        assert_pickle_arrays_almost_equal(
            target_relief_pickle_path, expected_raw_values_path)

    # @unittest.skip("skip relief")
    def test_long_aggregate_radius(self):
        from natcap.invest import coastal_vulnerability
        """Aggregate ratser values with a search radius that extends from
        a point beyond the extent of the raster"""

        workspace_dir = os.path.join(TEST_WORKSPACE_DIR, 'aggregate_radius')
        raster_path = os.path.join(workspace_dir, 'simple_raster.tif')
        target_pickle_path = os.path.join(workspace_dir, 'target.pickle')
        sample_distance = 3
        aggregation_mode = 'mean'

        # Make a simple raster
        srs = osr.SpatialReference()
        srs.ImportFromEPSG(26910)  # UTM Zone 10N
        projection_wkt = srs.ExportToWkt()
        geotransform = [0, 1.0, 0.0, 0, 0.0, -1.0]
        n = 3
        # fill_val = 1
        nodata_val = -1
        gtiff_driver = gdal.GetDriverByName('GTiff')
        new_raster = gtiff_driver.Create(
            raster_path, n, n, 1, gdal.GDT_Int32, options=[
                'TILED=YES', 'BIGTIFF=YES', 'COMPRESS=LZW',
                'BLOCKXSIZE=16', 'BLOCKYSIZE=16'])
        new_raster.SetProjection(projection_wkt)
        new_raster.SetGeoTransform(geotransform)
        new_band = new_raster.GetRasterBand(1)
        array = numpy.array(range(n**2)).reshape((n, n))
        # array.fill(fill_val)
        new_band.WriteArray(array)
        if nodata_val is not None:
            new_band.SetNoDataValue(nodata_val)
        new_raster.FlushCache()
        new_band = None
        new_raster = None

        # Make a vector proximate to the raster
        simple_points_path = os.path.join(workspace_dir, 'simple_points.shp')
        sampledata.create_vector_on_disk(
            [Point(0.2, -0.2),  # in pixel 0,0 - radius stays in bounds
             Point(1.2, -0.2),  # in pixel 1,0 - radius extends out of bounds
             ],
            srs.ExportToWkt(), filename=simple_points_path)

        coastal_vulnerability._aggregate_raster_values_in_radius(
            simple_points_path, raster_path, sample_distance,
            aggregation_mode, target_pickle_path)

        with open(target_pickle_path, 'rb') as file:
            actual_values = pickle.load(file)

        numpy.testing.assert_almost_equal(
            numpy.mean(actual_values.values()),
            numpy.mean(array))

    # @unittest.skip("skip complete run")
    def test_complete_run(self):
        from natcap.invest import coastal_vulnerability

        args = {'workspace_dir': '../invest_dev/coastal_vulnerability/test_workspace/complete_run',
                'n_workers': -1,
                'wwiii_vector_path': os.path.join(
                    INPUT_DATA, 'WaveWatchIII_subset.shp'),
                'landmass_vector_path': os.path.join(
                    INPUT_DATA, 'land_polygon_simple_utm.shp'),
                'aoi_vector_path': os.path.join(
                    INPUT_DATA, 'AOI_BarkClay.shp'),
                'model_resolution': 5000,
                'max_fetch_distance': 60000,
                'dem_path': "../invest-sample-data/Base_Data/Marine/DEMs/global_dem/hdr.adf",
                'dem_averaging_radius': 8000.0,
                'habitat_table_path': os.path.join(
                    INPUT_DATA, "natural_habitats_wcvi.csv"),
                'geomorphology_vector_path': os.path.join(
                    INPUT_DATA, "geomorphology_few_ranks.shp"),
                'geomorphology_fill_value': 3,
                # 'shelf_contour_vector_path': os.path.join(
                #     INPUT_DATA, 'continental_shelf_contour.gpkg'), # a polyline
                'shelf_contour_vector_path': os.path.join(
                    '../invest-sample-data/CoastalProtection/Input',
                    'continental_shelf_polyline.shp'),  # a global polyline
                'population_raster_path': os.path.join(
                    "../invest_dev/coastal_vulnerability/masked_global_pop_v2.tif"),
                'population_radius': 16000,
                }

        coastal_vulnerability.execute(args)

        # pygeoprocessing.testing.assert_vectors_equal(
        #     os.path.join(args['workspace_dir'], 'coastal_exposure.gpkg'),
        #     os.path.join(REGRESSION_DATA, 'expected_coastal_exposure.gpkg'),
        #     1e-6)
        actual_values_df = pandas.read_csv(
            os.path.join(args['workspace_dir'], 'coastal_exposure.csv'))
        expected_values_df = pandas.read_csv(
            os.path.join(REGRESSION_DATA, 'expected_coastal_exposure.csv'))

        pandas.testing.assert_frame_equal(actual_values_df, expected_values_df)

    def test_final_risk_calc(self):
        from natcap.invest import coastal_vulnerability

        workspace_dir = os.path.join(TEST_WORKSPACE_DIR, 'final_output')
        # TODO: pick a base vector with only the geom, not all wwiii fields.
        base_point_vector_path = os.path.join(
            INPUT_DATA, "wwiii_shore_points_5000m.gpkg")

        risk_id_path_list = [
            (os.path.join(REGRESSION_DATA, 'expected_relief.pickle'), True, 'R_relief'),
            (os.path.join(REGRESSION_DATA, 'expected_wind.pickle'), True, 'R_wind'),
            (os.path.join(REGRESSION_DATA, 'expected_wave.pickle'), True, 'R_wave'),
            (os.path.join(REGRESSION_DATA, 'expected_surge.pickle'), True, None)
            ]
        habitat_protection_path = os.path.join(
            REGRESSION_DATA, 'expected_habitat_protection.csv')
        target_intermediate_vector_path = os.path.join(workspace_dir, 'intermediate_exposure.gpkg')
        target_point_vector_path = os.path.join(workspace_dir, 'coastal_exposure.gpkg')
        target_point_csv_path = os.path.join(workspace_dir, 'coastal_exposure.csv')

        coastal_vulnerability.calculate_final_risk(
            risk_id_path_list, habitat_protection_path, base_point_vector_path,
            target_intermediate_vector_path, target_point_vector_path,
            target_point_csv_path)

        # TODO: add an assertion

    @unittest.skip("skip big habitat")
    def test_profile_habitat(self):
        from natcap.invest import coastal_vulnerability

        # workspace_dir = self.workspace_dir
        stacie_dir = "../invest_dev/coastal_vulnerability/stacie_data"
        workspace_dir = os.path.join(stacie_dir, 'habitat_dir')
        base_shore_point_vector_path = os.path.join(
            stacie_dir, "workspace_refactor/intermediate/shore_points/shore_points.gpkg")
        habitat_table_path = os.path.join(
            stacie_dir, "CV_inputs_draft1/habitat_CV_draft1_test.csv")
        target_habitat_protection_path = os.path.join(
            workspace_dir, 'habitat_protection.csv')
        file_suffix = ''

        coastal_vulnerability.calculate_habitat_protection(
            base_shore_point_vector_path,
            habitat_table_path, workspace_dir, file_suffix,
            target_habitat_protection_path)

        # expected_habitat_path = os.path.join(
        #     REGRESSION_DATA, 'expected_habitat_protection.csv')

        # actual_values_df = pandas.read_csv(target_habitat_protection_path)
        # expected_values_df = pandas.read_csv(expected_habitat_path)

        # pandas.testing.assert_frame_equal(actual_values_df, expected_values_df)


def assert_pickle_arrays_almost_equal(
        actual_values_pickle_path, expected_values_pickle_path):
    # target_raw_values_path = os.path.join(workspace_dir, 'relief.pickle')
    with open(actual_values_pickle_path, 'rb') as pickle_file:
        actual_values_dict = pickle.load(pickle_file)
    actual_values = actual_values_dict.values()
    
    # expected_raw_values_path = os.path.join(
    #     REGRESSION_DATA, 'expected_relief_values.pickle')
    with open(expected_values_pickle_path, 'rb') as pickle_file:
        expected_values_dict = pickle.load(pickle_file)
    expected_values = expected_values_dict.values()

    numpy.testing.assert_array_almost_equal(
        actual_values, expected_values, decimal=2)


def make_simple_raster(base_raster_path, fill_val, nodata_val):
    """Create a 10x10 raster on designated path with fill value.

    Parameters:
        raster_path (str): the raster path for making the new raster.
        fill_val (int): the value used for filling the raster.
        nodata_val (int or None): for defining a band's nodata value.

    """
    srs = osr.SpatialReference()
    srs.ImportFromEPSG(26910)  # UTM Zone 10N
    projection_wkt = srs.ExportToWkt()
    # origin hand-picked for this epsg:
    geotransform = [461261, 1.0, 0.0, 4923265, 0.0, -1.0]

    n = 3
    gtiff_driver = gdal.GetDriverByName('GTiff')
    new_raster = gtiff_driver.Create(
        base_raster_path, n, n, 1, gdal.GDT_Int32, options=[
            'TILED=YES', 'BIGTIFF=YES', 'COMPRESS=LZW',
            'BLOCKXSIZE=16', 'BLOCKYSIZE=16'])
    new_raster.SetProjection(projection_wkt)
    new_raster.SetGeoTransform(geotransform)
    new_band = new_raster.GetRasterBand(1)
    array = numpy.empty((n, n))
    array.fill(fill_val)
    new_band.WriteArray(array)
    if nodata_val is not None:
        new_band.SetNoDataValue(nodata_val)
    new_raster.FlushCache()
    new_band = None
    new_raster = None